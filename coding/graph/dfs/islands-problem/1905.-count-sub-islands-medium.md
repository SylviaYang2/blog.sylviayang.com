# 1905. Count Sub Islands (Medium)

You are given two `m x n` binary matrices `grid1` and `grid2` containing only `0`'s (representing water) and `1`'s (representing land). An **island** is a group of `1`'s connected **4-directionally** (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in `grid2` is considered a **sub-island** if there is an island in `grid1` that contains **all** the cells that make up **this** island in `grid2`.

Return the _**number** of islands in_ `grid2` _that are considered **sub-islands**_.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/06/10/test1.png)

<pre><code><strong>Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
</strong><strong>Output: 3
</strong><strong>Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
</strong>The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
</code></pre>

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png)

<pre><code><strong>Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
</strong><strong>Output: 2 
</strong><strong>Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
</strong>The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
</code></pre>

&#x20;

**Constraints:**

* `m == grid1.length == grid2.length`
* `n == grid1[i].length == grid2[i].length`
* `1 <= m, n <= 500`
* `grid1[i][j]` and `grid2[i][j]` are either `0` or `1`.



### Approach: DFS

什么情况下 `grid2` 中的一个岛屿 `B` 是 `grid1` 中的一个岛屿 `A` 的子岛？

当岛屿 `B` 中所有陆地在岛屿 `A` 中也是陆地的时候，岛屿 `B` 是岛屿 `A` 的子岛。

**反过来说，如果岛屿 `B` 中存在一片陆地，在岛屿 `A` 的对应位置是海水，那么岛屿 `B` 就不是岛屿 `A` 的子岛**。

那么，我们只要遍历 `grid2` 中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。



```java
class Solution {
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int res = 0;
        int m = grid1.length, n = grid1[0].length;
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                    // 这个岛屿肯定不是子岛，淹掉
                    dfs(grid2, i, j);
                }
            }
        }

        // 剩下的grid2中的岛屿一定是子岛
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    res++;
                    dfs(grid2, i, j);
                }
            }
        }
        return res;
    }

    private void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return;
        }
        // if grid[i][j] already the water, skip
        if (grid[i][j] == 0) {
            return;
        }

        // flood the cell
        grid[i][j] = 0;
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
}
```

**Complexity Analysis**

* Time complexity : $$O(M×N)$$ where $$M$$ is the number of rows and\
  $$N$$ is the number of columns.
* Space complexity : worst case $$O(M×N)$$ in case that the grid map\
  is filled with lands where DFS goes by $$M×N$$ deep.
