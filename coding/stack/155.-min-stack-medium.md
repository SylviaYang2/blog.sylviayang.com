# 155. Min Stack (Medium)

<figure><img src="../../.gitbook/assets/image (50) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (51) (1).png" alt=""><figcaption></figcaption></figure>

### Approach 1: Stack of \[value, minVal] Pair

````java
```java
class MinStack {
    private Stack<int[]> stack = new Stack<>();
    
    public MinStack() {
    }
    
    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(new int[]{val, val});
            return;
        }
        int minVal = stack.peek()[1];
        stack.push(new int[]{val, Math.min(minVal, val)});
    }
    
    public void pop() {
        stack.pop();
    }
    
    public int top() {
        return stack.peek()[0];
    }
    
    public int getMin() {
        return stack.peek()[1];
    }
}
```
````

**Complexity Analysis**

Let $$n$$ be the total number of operations performed.

*   Time Complexity : $$O(1)$$ for all operations.

    `push(...)`: Checking the top of a `Stack`, comparing numbers, and pushing to the top of a `Stack` (or adding to the _end_ of an Array or List) are all $$O(1)$$ operations. Therefore, this overall is an $$O(1)$$ operation.

    `pop(...)`: Popping from a `Stack` (or removing from the _end_ of an Array, or List) is an $$O(1)$$ operation.

    `top(...)`: Looking at the top of a `Stack` is an $$O(1)$$ operation.

    `getMin(...)`: Same as above. This operation is $$O(1)$$ because we do _not_ need to compare values to find it. If we had not kept track of it on the `Stack`, and instead had to search for it each time, the overall time complexity would have been $$O(n)$$.
*   Space Complexity : $$O(n)$$.

    Worst case is that all the operations are `push`. In this case, there will be $$O(2â‹…n)=O(n)$$ space used.

\


### Approach 2: Two Stacks - one for current values, one for min tracker

````java
```java
class MinStack {
    // Approach 2: using two stacks
    private Stack<Integer> stack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();

    public MinStack() {
    }
    
    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }
    
    public void pop() {
        if (stack.peek().equals(minStack.peek())) {
            minStack.pop();
        }
        stack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```
````

**Complexity Analysis**

* Time Complexity : $$O(1)$$ for all operations.
* Space Complexity : $$O(n)$$
