# 309. Best Time to Buy and Sell Stock with Cooldown (Medium)

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:

* After you sell your stock, you **cannot buy stock on the next day (i.e., cooldown one day).**

**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

**Example 1:**

<pre><code><strong>Input: prices = [1,2,3,0,2]
</strong><strong>Output: 3
</strong><strong>Explanation: transactions = [buy, sell, cooldown, buy, sell]
</strong></code></pre>

**Example 2:**

<pre><code><strong>Input: prices = [1]
</strong><strong>Output: 0
</strong></code></pre>

**Constraints:**

* `1 <= prices.length <= 5000`
* `0 <= prices[i] <= 1000`



### Approach: DP

```java
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
```

```java
base case：
dp[-1][...][0] = dp[...][0][0] = 0
dp[-1][...][1] = dp[...][0][1] = -infinity
```

没有给出交易总数 `k` 的限制，也就相当于 `k` 为正无穷。

如果 `k` 为正无穷，那么就可以认为 `k` 和 `k - 1, k - 2`是一样的。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];

        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                dp[i][0] = 0;
                // 根据状态转移方程可得：
                //   dp[i][0] 
                // = max(dp[-1][0], dp[-1][1] + prices[i])
                // = max(0, -infinity + prices[i]) = 0

                dp[i][1] = -prices[i];
                // 根据状态转移方程可得：
                //   dp[i][1] 
                // = max(dp[-1][1], dp[-1][0] - prices[i])
                // = max(-infinity, 0 - prices[i]) 
                // = -prices[i]
                continue;
            }

            if (i - 2 == -1) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                //   dp[i][1] 
                // = max(dp[i-1][1], dp[-1][0] - prices[i])
                // = max(dp[i-1][1], 0 - prices[i])
                // = max(dp[i-1][1], -prices[i])
                dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
                continue;
            }

            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
}
```

### **Complexity Analysis**

Let $$n$$ be the length of the input array `prices`.

* Time complexity: $$O(n)$$
* Space complexity: $$O(n)$$
  * We an array of length `n` to record the maximum profit with two status on each day.
